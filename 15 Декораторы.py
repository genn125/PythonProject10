# Декораторы

def dekorator(fn):  # передается вся ф-ия my_function как параметр fn.
    def wrapper(*args, **kwargs):     # Сюда передаются автоматически параметры из вызова my_function, wrapper_f посредник
                                      # И передает аргументы в fn().
# Действия перед исполнением оригинальной функции.
        print(f'Выполнено перед выполнением функции: {fn.__name__}')
        print(f'Имя моей функции: {fn.__name__}')
        print(f'Аргументы моей функции: {args}, {kwargs}','\n')
        res = fn(*args, **kwargs)
# Действия после исполнением оригинальной функции.
        print(f'Выполнено после выполнением функции {fn.__name__}')
        print(f'А внутри wrapper(*args, **kwargs) есть доступ к результату выполнения {fn.__name__}, вот он: ', res)
        return res

    return wrapper    # не вызываем (без скобок()), а просто возвращаем результат wrapper_f.

#  Декоратор. Передаёт всю последующую в функцию dekorator.
@dekorator
def my_function(a, b):
    print('Это моя функция my_function()''\n')
    return a * b
#  так как wrapper(*args, **kwargs), то можно передавать любые аргументы
print('\n', '1 - конечный результат: ', my_function(5,2))     # Аргументы моей функции: (5, 2), {}
print('###################')

@dekorator
def summ(a, b):
    return a + b
print('\n', '1 - конечный результат: ', summ(a=40.4, b=56.6))     # Аргументы моей функции: (), {'а': 40.4, 'b': 56.6}
print('###################')